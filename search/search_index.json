{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Installation \u00b6 Download the latest build of oxmysql (not the source code). Extract the contents of the archive to your resources folder. Start the resource near the top of your resources in your server.cfg . If you have a lot of streamed assets, load them first to prevent timing out the connection. Configuration \u00b6 You can change the configuration settings by using convars inside your server.cfg . Reference the following for an idea of how to set your connection options. You must include one of the following lines, adjusted for your connection and database settings. set mysql_connection_string \"mysql://root:12345@localhost/es_extended?charset=utf8mb4\" set mysql_connection_string \"user=root;database=es_extended;password=12345;charset=utf8mb4\" Certain special characters are reserved or blocked and may cause issues when used in your password. You can also add the following convars if you require extra information when testing queries. set mysql_slow_query_warning 150 set mysql_debug true Using the UI \u00b6 Info Before using the UI first you have to make sure you have the mysql_ui convar set to true: set mysql_ui true Also make sure that you have command ace permission access, then you should be able to use the mysql command in game to open up the UI and see your query data. For more optional settings (such as multiple statements) you can reference pool.d.ts and connection.d.ts . Benchmark \u00b6 Lua: Low: 0.2167ms | Avg: 0.28788843ms | Total: 2878.8843ms (10000 queries) JS: Low: 0.2098ms | Avg: 0.29384436ms | Total: 2938.4436ms (10000 queries) These benchmarks await the previous response rather than occuring asynchronously, and measure the total time spent executing the export. The MySQL.Sync.prepare function calls exports.oxmysql:execute_async , as used in the JS sample. Lua (5.4) \u00b6 local val = 10000 RegisterCommand ( 'luasync' , function () local queryTimesLocal = {} local result local r = MySQL . Sync . prepare ( 'SELECT identifier from users WHERE lastname = ?' , { 'Linden' }) for i = 1 , val do local time = os . nanotime () local r = MySQL . Sync . prepare ( 'SELECT identifier from users WHERE lastname = ?' , { 'Linden' }) queryTimesLocal [ # queryTimesLocal + 1 ] = ( os . nanotime () - time ) / 1000000 if i == 1 then result = r end end local queryMsLow , queryMsSum = 1000 , 0 for _ , v in pairs ( queryTimesLocal ) do queryMsSum = queryMsSum + v end for _ , v in pairs ( queryTimesLocal ) do if v < queryMsLow then queryMsLow = v end end local averageQueryTime = queryMsSum / # queryTimesLocal print ( json . encode ( result )) print ( 'Low: ' .. queryMsLow .. 'ms | Avg: ' .. averageQueryTime .. 'ms | Total: ' .. queryMsSum .. 'ms (' ..# queryTimesLocal .. ' queries)' ) end ) JavaScript \u00b6 const val = 10000 RegisterCommand ( 'jssync' , async () => { const queryTimesLocal = []; let result for ( let i = 0 ; i < val ; i ++ ) { const startTime = process . hrtime () const r = await exports . oxmysql . execute_async ( 'SELECT identifier from users WHERE lastname = ?' , [ 'Linden' ]) queryTimesLocal . push ( process . hrtime ( startTime )[ 1 ] / 1000000 ) if ( i === 0 ) result = r } const queryMsSum = queryTimesLocal . reduce (( a , b ) => a + b , 0 ) const queryMsLow = queryTimesLocal . sort (( a , b ) => a - b )[ 0 ] const averageQueryTime = queryMsSum / queryTimesLocal . length console . log ( result ) console . log ( 'Low: ' + queryMsLow + 'ms | Avg: ' + averageQueryTime + 'ms | Total: ' + queryMsSum + 'ms (' + queryTimesLocal . length + ' queries)' ) })","title":"Getting Started"},{"location":"#installation","text":"Download the latest build of oxmysql (not the source code). Extract the contents of the archive to your resources folder. Start the resource near the top of your resources in your server.cfg . If you have a lot of streamed assets, load them first to prevent timing out the connection.","title":"Installation"},{"location":"#configuration","text":"You can change the configuration settings by using convars inside your server.cfg . Reference the following for an idea of how to set your connection options. You must include one of the following lines, adjusted for your connection and database settings. set mysql_connection_string \"mysql://root:12345@localhost/es_extended?charset=utf8mb4\" set mysql_connection_string \"user=root;database=es_extended;password=12345;charset=utf8mb4\" Certain special characters are reserved or blocked and may cause issues when used in your password. You can also add the following convars if you require extra information when testing queries. set mysql_slow_query_warning 150 set mysql_debug true","title":"Configuration"},{"location":"#using-the-ui","text":"Info Before using the UI first you have to make sure you have the mysql_ui convar set to true: set mysql_ui true Also make sure that you have command ace permission access, then you should be able to use the mysql command in game to open up the UI and see your query data. For more optional settings (such as multiple statements) you can reference pool.d.ts and connection.d.ts .","title":"Using the UI"},{"location":"#benchmark","text":"Lua: Low: 0.2167ms | Avg: 0.28788843ms | Total: 2878.8843ms (10000 queries) JS: Low: 0.2098ms | Avg: 0.29384436ms | Total: 2938.4436ms (10000 queries) These benchmarks await the previous response rather than occuring asynchronously, and measure the total time spent executing the export. The MySQL.Sync.prepare function calls exports.oxmysql:execute_async , as used in the JS sample.","title":"Benchmark"},{"location":"#lua-54","text":"local val = 10000 RegisterCommand ( 'luasync' , function () local queryTimesLocal = {} local result local r = MySQL . Sync . prepare ( 'SELECT identifier from users WHERE lastname = ?' , { 'Linden' }) for i = 1 , val do local time = os . nanotime () local r = MySQL . Sync . prepare ( 'SELECT identifier from users WHERE lastname = ?' , { 'Linden' }) queryTimesLocal [ # queryTimesLocal + 1 ] = ( os . nanotime () - time ) / 1000000 if i == 1 then result = r end end local queryMsLow , queryMsSum = 1000 , 0 for _ , v in pairs ( queryTimesLocal ) do queryMsSum = queryMsSum + v end for _ , v in pairs ( queryTimesLocal ) do if v < queryMsLow then queryMsLow = v end end local averageQueryTime = queryMsSum / # queryTimesLocal print ( json . encode ( result )) print ( 'Low: ' .. queryMsLow .. 'ms | Avg: ' .. averageQueryTime .. 'ms | Total: ' .. queryMsSum .. 'ms (' ..# queryTimesLocal .. ' queries)' ) end )","title":"Lua (5.4)"},{"location":"#javascript","text":"const val = 10000 RegisterCommand ( 'jssync' , async () => { const queryTimesLocal = []; let result for ( let i = 0 ; i < val ; i ++ ) { const startTime = process . hrtime () const r = await exports . oxmysql . execute_async ( 'SELECT identifier from users WHERE lastname = ?' , [ 'Linden' ]) queryTimesLocal . push ( process . hrtime ( startTime )[ 1 ] / 1000000 ) if ( i === 0 ) result = r } const queryMsSum = queryTimesLocal . reduce (( a , b ) => a + b , 0 ) const queryMsLow = queryTimesLocal . sort (( a , b ) => a - b )[ 0 ] const averageQueryTime = queryMsSum / queryTimesLocal . length console . log ( result ) console . log ( 'Low: ' + queryMsLow + 'ms | Avg: ' + averageQueryTime + 'ms | Total: ' + queryMsSum + 'ms (' + queryTimesLocal . length + ' queries)' ) })","title":"JavaScript"},{"location":"issues/","text":"Unable to establish a connection \u00b6 This is usually the result of incorrect database settings or your password containing reserved characters (typically ; , / ? : @ & = + $ # ). Solution Ensure you have entered the correct database settings in the mysql_connection_string convar. You can try using the semicolon-separated format if your password contains reserved characters. No such export ... in resource oxmysql \u00b6 Typically the result of failing to follow instructions. Solution Download the latest release build (not source) of oxmysql, and ensure it is starting before any resources that require it.","title":"Common issues"},{"location":"issues/#unable-to-establish-a-connection","text":"This is usually the result of incorrect database settings or your password containing reserved characters (typically ; , / ? : @ & = + $ # ). Solution Ensure you have entered the correct database settings in the mysql_connection_string convar. You can try using the semicolon-separated format if your password contains reserved characters.","title":"Unable to establish a connection"},{"location":"issues/#no-such-export-in-resource-oxmysql","text":"Typically the result of failing to follow instructions. Solution Download the latest release build (not source) of oxmysql, and ensure it is starting before any resources that require it.","title":"No such export ... in resource oxmysql"},{"location":"usage/","text":"todo - include some information about proper formatting, placeholders, bad practices, etc.","title":"Index"},{"location":"usage/insert/","text":"Inserts a new entry into the database and returns the insert id for the row, if valid. Example Lua Callback -- Alias: exports.oxmysql:insert -- Alias: MySQL.Async.insert MySQL . insert ( 'INSERT INTO users (identifier, firstname, lastname) VALUES (?, ?, ?) ' , { playerIdentifier , firstName , lastName }, function ( id ) print ( id ) end ) Promise -- Alias: exports.oxmysql:insert_async -- Alias: MySQL.Sync.insert CreateThread ( function () local id = MySQL . insert . await ( 'INSERT INTO users (identifier, firstname, lastname) VALUES (?, ?, ?) ' , { playerIdentifier , firstName , lastName }) print ( id ) end ) JavaScript Callback exports . oxmysql . insert ( 'INSERT INTO users (identifier, firstname, lastname) VALUES (?, ?, ?) ' , [ playerIdentifier , firstName , lastName ], function ( id ) { console . log ( id ) }) Promise ( async () => { const id = exports . oxmysql . insert_async ( 'INSERT INTO users (identifier, firstname, lastname) VALUES (?, ?, ?) ' , [ playerIdentifier , firstName , lastName ]) { console . log ( id ) })()","title":"insert"},{"location":"usage/prepare/","text":"The only function that provides true prepared statements , granting native protection and query planning by MySQL. Prepare can be used to execute frequently called queries faster and accepts multiple sets of parameters to be used with a single query. Date will not return the datestring commonly used in FiveM TINYINT 1 and BIT will not return a boolean You can only use ? value placeholders, ?? column placeholders and named placeholders will throw an error When using SELECT, the return value will match fetchAll, fetchSingle, or fetchScalar depending on the number of columns and rows selected. Example Lua Callback -- Alias: exports.oxmysql:prepare -- Alias: MySQL.Async.prepare MySQL . prepare ( 'SELECT * FROM users WHERE identifier = ?' , { playerIdentifier }, function ( result ) if result then for _ , v in pairs ( result ) do print ( v . identifier , v . firstname , v . lastname ) end end end ) Promise -- Alias: exports.oxmysql:prepare_async -- Alias: MySQL.Sync.prepare CreateThread ( function () local result = MySQL . prepare . await ( 'SELECT * FROM users WHERE identifier = ?' , { playerIdentifier }) if result then for _ , v in pairs ( result ) do print ( v . identifier , v . firstname , v . lastname ) end end end ) JavaScript Callback exports . oxmysql . prepare ( 'SELECT * FROM users WHERE identifier = ?' , [ playerIdentifier ], function ( result ) { if ( result ) { result . forEach (( v ) => { console . log ( v . identifier , v . firstname , v . lastname ) }) } }) Promise ( async () => { const result = await exports . oxmysql . prepare_async ( 'SELECT * FROM users WHERE identifier = ?' , [ playerIdentifier ]) { if ( result ) { result . forEach (( v ) => { console . log ( v . identifier , v . firstname , v . lastname ) }) } })() As mentioned above, you can utilise an array of parameters for a transaction-like query without the rollback; reducing the number of exports being performed reduces strain on the server. Included below is some examples of using prepare in ESX Legacy. ESX . SavePlayer = function ( xPlayer , cb ) MySQL . Async . prepare ( \"UPDATE `users` SET `accounts` = ?, `job` = ?, `job_grade` = ?, `group` = ?, `position` = ?, `inventory` = ? WHERE `identifier` = ?\" , {{ json . encode ( xPlayer . getAccounts ( true )), xPlayer . job . name , xPlayer . job . grade , xPlayer . group , json . encode ( xPlayer . getCoords ()), json . encode ( xPlayer . getInventory ( true )), xPlayer . identifier }}, function ( affectedRows ) if affectedRows == 1 then print (( '[^2INFO^7] Saved player ^5\"%s^7\"' ): format ( xPlayer . name )) end if cb then cb () end end ) end ESX . SavePlayers = function ( cb ) local xPlayers = ESX . GetExtendedPlayers () local count = # xPlayers if count > 0 then local parameters = {} for i = 1 , count do local xPlayer = xPlayers [ i ] parameters [ # parameters + 1 ] = { json . encode ( xPlayer . getAccounts ( true )), xPlayer . job . name , xPlayer . job . grade , xPlayer . group , json . encode ( xPlayer . getCoords ()), json . encode ( xPlayer . getInventory ( true )), xPlayer . identifier } end MySQL . Async . prepare ( \"UPDATE `users` SET `accounts` = ?, `job` = ?, `job_grade` = ?, `group` = ?, `position` = ?, `inventory` = ? WHERE `identifier` = ?\" , parameters , function ( results ) if results then if type ( cb ) == 'function' then cb () else print (( '[^2INFO^7] Saved %s %s' ): format ( count , count > 1 and 'players' or 'player' ) end end end ) end end","title":"prepare"},{"location":"usage/query/","text":"Generic function that can be utilised for any query. When selecting data it will return all matching rows and columns, otherwise it will return field data such as insertid, affectedRows, etc. Example Lua Callback -- Alias: exports.oxmysql:query -- Alias: MySQL.Async.query MySQL . query ( 'SELECT * FROM users WHERE identifier = ?' , { playerIdentifier }, function ( result ) if result then for _ , v in pairs ( result ) do print ( v . identifier , v . firstname , v . lastname ) end end end ) Promise -- Alias: exports.oxmysql:query -- Alias: MySQL.Sync.query CreateThread ( function () local result = MySQL . query . await ( 'SELECT * FROM users WHERE identifier = ?' , { playerIdentifier }) if result then for _ , v in pairs ( result ) do print ( v . identifier , v . firstname , v . lastname ) end end end ) JavaScript Callback exports . oxmysql . query ( 'SELECT * FROM users WHERE identifier = ?' , [ playerIdentifier ], function ( result ) { if ( result ) { result . forEach (( v ) => { console . log ( v . identifier , v . firstname , v . lastname ) }) } }) Promise ( async () => { const result = await exports . oxmysql . query_async ( 'SELECT * FROM users WHERE identifier = ?' , [ playerIdentifier ]) { if ( result ) { result . forEach (( v ) => { console . log ( v . identifier , v . firstname , v . lastname ) }) } })()","title":"query"},{"location":"usage/scalar/","text":"Returns the first column for a single row. Example Lua Callback -- Alias: exports.oxmysql:scalar -- Alias: MySQL.Async.fetchScalar MySQL . scalar ( 'SELECT firstname FROM users WHERE identifier = ?' , { playerIdentifier }, function ( firstname ) print ( firstname ) end ) Promise -- Alias: exports.oxmysql:scalar_async -- Alias: MySQL.Sync.fetchScalar CreateThread ( function () local firstname = MySQL . scalar . await ( 'SELECT firstname FROM users WHERE identifier = ?' , { playerIdentifier }) print ( firstname ) end ) JavaScript Callback exports . oxmysql . scalar ( 'SELECT firstname FROM users WHERE identifier = ?' , [ playerIdentifier ], function ( firstname ) { console . log ( firstname ) }) Promise ( async () => { const firstname = await exports . oxmysql . scalar_async ( 'SELECT firstname FROM users WHERE identifier = ?' , [ playerIdentifier ]) { console . log ( firstname ) })()","title":"scalar"},{"location":"usage/single/","text":"Returns the columns for a single row. Example Lua Callback -- Alias: exports.oxmysql:single -- Alias: MySQL.Async.fetchSingle MySQL . single ( 'SELECT * FROM users WHERE identifier = ?' , { playerIdentifier }, function ( result ) if result then print ( result . identifier , result . firstname , result . lastname ) end end ) Promise -- Alias: exports.oxmysql:single_async -- Alias: MySQL.Sync.fetchSingle CreateThread ( function () local result = MySQL . single . await ( 'SELECT * FROM users WHERE identifier = ?' , { playerIdentifier }) if result then print ( result . identifier , result . firstname , result . lastname ) end end ) JavaScript Callback exports . oxmysql . single ( 'SELECT * FROM users WHERE identifier = ?' , [ playerIdentifier ], function ( result ) { if ( result ) console . log ( result . identifier , result . firstname , result . lastname ) }) Promise setImmediate ( async () => { const result = await exports . oxmysql . single_async ( 'SELECT * FROM users WHERE identifier = ?' , [ playerIdentifier ]) { if ( result ) console . log ( result . identifier , result . firstname , result . lastname ) })","title":"single"},{"location":"usage/transaction/","text":"todo - update formatting and information Transactions \u00b6 A transaction executes multiple queries and commits them only if all succeed. If one fails, none of the queries are committed. The return value is a boolean , which is the result of the transaction. Specific Format \u00b6 When using the Specific format you must pass one parameter to the oxmysql export. In this case, the queries parameter contains your queries and the SQL variables unique to each query. This is useful for transactions where the queries do not share many SQL variables. Usage \u00b6 Lua local queries = { { query = 'INSERT INTO `test` (id) VALUES (:someid)' , values = { [ 'someid' ] = 1 } }, { query = 'INSERT INTO `test` (id) VALUES (:someid)' , values = { [ 'someid' ] = 2 } } } -- NOTE, the 'values' tables can be named 'parameters' here for MySQL-Async compatibility. -- Async exports . oxmysql : transaction ( queries , function ( result ) print ( result ) end ) -- Sync local result = exports . oxmysql : transactionSync ( queries ) print ( result ) JavaScript const queries = [ { query = 'INSERT INTO `test` (id) VALUES (:someid)' , values = { someid = 1 } }, { query = 'INSERT INTO `test` (id) VALUES (:someid)' , values = { someid = 2 } } ] // NOTE, the 'values' objects can be named 'parameters' here for MySQL-Async compatibility. // Async exports . oxmysql . transaction ( queries , ( result ) => { console . log ( result ) }) // Sync const result = await exports . oxmysql . transactionSync ( queries ) console . log ( result ) Shared Format \u00b6 When using the Shared format you must pass two parameters to the oxmysql export. The queries and the parameters those queries will use. This is useful if your queries use the same SQL variables. Lua local queries = { 'INSERT INTO `test` (id, name) VALUES (:someid, :somename)' , 'SET `name` = :newname IN `test` WHERE `id` = :someid' } local parameters = { [ 'someid' ] = 2 , [ 'somename' ] = 'John Doe' , [ 'newname' ] = 'John Notdoe' } -- Async exports . oxmysql : transaction ( queries , parameters , function ( result ) print ( result ) end ) -- Sync local result = exports . oxmysql : transactionSync ( queries , parameters ) print ( result ) JavaScript const queries = [ 'INSERT INTO `test` (id, name) VALUES (:someid, :somename)' , 'SET `name` = :newname IN `test` WHERE `id` = :someid' ] const parameters = { someid = 2 , somename = 'John Doe' , newname = 'John Notdoe' } // Async exports . oxmysql . transaction ( queries , parameters , ( result ) => { console . log ( result ) }) // Sync const result = await exports . oxmysql . transactionSync ( queries , parameters ) console . log ( result ) Transaction Isolation Level \u00b6 This can be set through the convar mysql_transaction_isolation_level which should be an integer ranging from 1-4 . The default convar value set by oxmysql is 2 . Convar Value Result 1 Repeatable Read 2 Read Committed 3 Read Uncommitted 4 Serializable","title":"transaction"},{"location":"usage/transaction/#transactions","text":"A transaction executes multiple queries and commits them only if all succeed. If one fails, none of the queries are committed. The return value is a boolean , which is the result of the transaction.","title":"Transactions"},{"location":"usage/transaction/#specific-format","text":"When using the Specific format you must pass one parameter to the oxmysql export. In this case, the queries parameter contains your queries and the SQL variables unique to each query. This is useful for transactions where the queries do not share many SQL variables.","title":"Specific Format"},{"location":"usage/transaction/#usage","text":"Lua local queries = { { query = 'INSERT INTO `test` (id) VALUES (:someid)' , values = { [ 'someid' ] = 1 } }, { query = 'INSERT INTO `test` (id) VALUES (:someid)' , values = { [ 'someid' ] = 2 } } } -- NOTE, the 'values' tables can be named 'parameters' here for MySQL-Async compatibility. -- Async exports . oxmysql : transaction ( queries , function ( result ) print ( result ) end ) -- Sync local result = exports . oxmysql : transactionSync ( queries ) print ( result ) JavaScript const queries = [ { query = 'INSERT INTO `test` (id) VALUES (:someid)' , values = { someid = 1 } }, { query = 'INSERT INTO `test` (id) VALUES (:someid)' , values = { someid = 2 } } ] // NOTE, the 'values' objects can be named 'parameters' here for MySQL-Async compatibility. // Async exports . oxmysql . transaction ( queries , ( result ) => { console . log ( result ) }) // Sync const result = await exports . oxmysql . transactionSync ( queries ) console . log ( result )","title":"Usage"},{"location":"usage/transaction/#shared-format","text":"When using the Shared format you must pass two parameters to the oxmysql export. The queries and the parameters those queries will use. This is useful if your queries use the same SQL variables. Lua local queries = { 'INSERT INTO `test` (id, name) VALUES (:someid, :somename)' , 'SET `name` = :newname IN `test` WHERE `id` = :someid' } local parameters = { [ 'someid' ] = 2 , [ 'somename' ] = 'John Doe' , [ 'newname' ] = 'John Notdoe' } -- Async exports . oxmysql : transaction ( queries , parameters , function ( result ) print ( result ) end ) -- Sync local result = exports . oxmysql : transactionSync ( queries , parameters ) print ( result ) JavaScript const queries = [ 'INSERT INTO `test` (id, name) VALUES (:someid, :somename)' , 'SET `name` = :newname IN `test` WHERE `id` = :someid' ] const parameters = { someid = 2 , somename = 'John Doe' , newname = 'John Notdoe' } // Async exports . oxmysql . transaction ( queries , parameters , ( result ) => { console . log ( result ) }) // Sync const result = await exports . oxmysql . transactionSync ( queries , parameters ) console . log ( result )","title":"Shared Format"},{"location":"usage/transaction/#transaction-isolation-level","text":"This can be set through the convar mysql_transaction_isolation_level which should be an integer ranging from 1-4 . The default convar value set by oxmysql is 2 . Convar Value Result 1 Repeatable Read 2 Read Committed 3 Read Uncommitted 4 Serializable","title":"Transaction Isolation Level"},{"location":"usage/update/","text":"Returns the number of affected rows by the query. Example Lua Callback -- Alias: exports.oxmysql:update -- Alias: MySQL.Async.update MySQL . Async . update ( 'UPDATE users SET firstname = ? WHERE identifier = ? ' , { newName , playerIdentifier }, function ( affectedRows ) if affectedRows then print ( affectedRows ) end end ) Promise -- Alias: exports.oxmysql:update_async -- Alias: MySQL.update CreateThread ( function () local affectedRows = MySQL . update . await ( 'UPDATE users SET firstname = ? WHERE identifier = ? ' , { newName , playerIdentifier }) if affectedRows then print ( affectedRows ) end end ) JavaScript Callback exports . oxmysql . update ( 'UPDATE users SET firstname = ? WHERE identifier = ? ' , [ newName , playerIdentifier ], function ( affectedRows ) { if ( affectedRows ) console . log ( affectedRows ) }) Promise setImmediate ( async () => { const id = exports . oxmysql . update_async ( 'UPDATE users SET firstname = ? WHERE identifier = ? ' , [ newName , playerIdentifier ]) { if ( affectedRows ) console . log ( affectedRows ) })","title":"update"}]}